import { __decorate } from 'tslib';
import { ɵstringify, ViewContainerRef, ChangeDetectorRef, TemplateRef, Input, Directive, NgModule } from '@angular/core';
import { Subject, AsyncSubject } from 'rxjs';
import { concatMap, takeUntil } from 'rxjs/operators';

function assertTemplate(property, templateRef) {
    const isTemplateRefOrNull = !!(!templateRef || templateRef.createEmbeddedView);
    if (!isTemplateRefOrNull) {
        throw new Error(`${property} must be a TemplateRef, but received '${ɵstringify(templateRef)}'.`);
    }
}
class ObserveContext {
    constructor(value) {
        this.$implicit = value;
        this.ngxObserve = value;
    }
}
class ErrorContext {
    constructor(error) {
        this.$implicit = error;
    }
}
let NgxObserve = class NgxObserve {
    constructor(view, changes, nextTemplateRef) {
        this.view = view;
        this.changes = changes;
        this.unsubscribe = new Subject();
        this.init = new AsyncSubject();
        this.nextTemplateRef = nextTemplateRef;
    }
    set ngxObserve(source) {
        if (this.source && source !== this.source) {
            this.unsubscribe.next(undefined);
        }
        if (source && source !== this.source) {
            if (this.beforeTemplateRef) {
                this.view.clear();
                this.nextViewRef = undefined;
                this.errorViewRef = undefined;
                this.beforeViewRef = this.view.createEmbeddedView(this.beforeTemplateRef);
            }
            this.init.pipe(concatMap(() => {
                if (this.beforeTemplateRef) {
                    this.view.clear();
                    this.nextViewRef = undefined;
                    this.errorViewRef = undefined;
                    this.beforeViewRef = this.view.createEmbeddedView(this.beforeTemplateRef);
                }
                return source;
            }), takeUntil(this.unsubscribe)).subscribe(value => {
                this.view.clear();
                this.errorViewRef = undefined;
                this.beforeViewRef = undefined;
                this.nextViewRef = this.view.createEmbeddedView(this.nextTemplateRef, new ObserveContext(value));
                this.changes.markForCheck();
            }, error => {
                if (this.errorTemplateRef) {
                    this.view.clear();
                    this.beforeViewRef = undefined;
                    this.nextViewRef = undefined;
                    this.errorViewRef = this.view.createEmbeddedView(this.errorTemplateRef, new ErrorContext(error));
                    this.changes.markForCheck();
                }
            });
        }
        this.source = source;
    }
    set ngxObserveError(ref) {
        assertTemplate('ngxObserveError', ref);
        this.errorTemplateRef = ref;
        if (this.errorViewRef) {
            this.view.clear();
            this.errorViewRef = this.view.createEmbeddedView(this.errorTemplateRef, this.errorViewRef.context);
        }
    }
    set ngxObserveBefore(ref) {
        assertTemplate('ngxObserveBefore', ref);
        this.beforeTemplateRef = ref;
        if (this.beforeViewRef) {
            this.view.clear();
            this.beforeViewRef = this.view.createEmbeddedView(this.beforeTemplateRef);
        }
    }
    set ngxObserveNext(ref) {
        assertTemplate('ngxObserveNext', ref);
        this.nextTemplateRef = ref;
        if (this.nextViewRef) {
            this.view.clear();
            this.nextViewRef = this.view.createEmbeddedView(this.nextTemplateRef, this.nextViewRef.context);
            this.changes.markForCheck();
        }
    }
    static ngTemplateContextGuard(dir, ctx) {
        return true;
    }
    ngOnDestroy() {
        this.unsubscribe.next(undefined);
    }
    ngOnInit() {
        this.init.next(undefined);
        this.init.complete();
    }
};
NgxObserve.ctorParameters = () => [
    { type: ViewContainerRef },
    { type: ChangeDetectorRef },
    { type: TemplateRef }
];
__decorate([
    Input()
], NgxObserve.prototype, "ngxObserve", null);
__decorate([
    Input()
], NgxObserve.prototype, "ngxObserveError", null);
__decorate([
    Input()
], NgxObserve.prototype, "ngxObserveBefore", null);
__decorate([
    Input()
], NgxObserve.prototype, "ngxObserveNext", null);
NgxObserve = __decorate([
    Directive({
        selector: '[ngxObserve]'
    })
], NgxObserve);

let NgxObserveModule = class NgxObserveModule {
};
NgxObserveModule = __decorate([
    NgModule({
        declarations: [NgxObserve],
        imports: [],
        exports: [NgxObserve]
    })
], NgxObserveModule);

/*
 * Public API Surface of ngx-observe
 */

/**
 * Generated bundle index. Do not edit.
 */

export { ErrorContext, NgxObserve, NgxObserveModule, ObserveContext };
//# sourceMappingURL=ngx-observe.js.map
