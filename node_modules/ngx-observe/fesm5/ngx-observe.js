import { __decorate } from 'tslib';
import { ɵstringify, ViewContainerRef, ChangeDetectorRef, TemplateRef, Input, Directive, NgModule } from '@angular/core';
import { Subject, AsyncSubject } from 'rxjs';
import { concatMap, takeUntil } from 'rxjs/operators';

function assertTemplate(property, templateRef) {
    var isTemplateRefOrNull = !!(!templateRef || templateRef.createEmbeddedView);
    if (!isTemplateRefOrNull) {
        throw new Error(property + " must be a TemplateRef, but received '" + ɵstringify(templateRef) + "'.");
    }
}
var ObserveContext = /** @class */ (function () {
    function ObserveContext(value) {
        this.$implicit = value;
        this.ngxObserve = value;
    }
    return ObserveContext;
}());
var ErrorContext = /** @class */ (function () {
    function ErrorContext(error) {
        this.$implicit = error;
    }
    return ErrorContext;
}());
var NgxObserve = /** @class */ (function () {
    function NgxObserve(view, changes, nextTemplateRef) {
        this.view = view;
        this.changes = changes;
        this.unsubscribe = new Subject();
        this.init = new AsyncSubject();
        this.nextTemplateRef = nextTemplateRef;
    }
    Object.defineProperty(NgxObserve.prototype, "ngxObserve", {
        set: function (source) {
            var _this = this;
            if (this.source && source !== this.source) {
                this.unsubscribe.next(undefined);
            }
            if (source && source !== this.source) {
                if (this.beforeTemplateRef) {
                    this.view.clear();
                    this.nextViewRef = undefined;
                    this.errorViewRef = undefined;
                    this.beforeViewRef = this.view.createEmbeddedView(this.beforeTemplateRef);
                }
                this.init.pipe(concatMap(function () {
                    if (_this.beforeTemplateRef) {
                        _this.view.clear();
                        _this.nextViewRef = undefined;
                        _this.errorViewRef = undefined;
                        _this.beforeViewRef = _this.view.createEmbeddedView(_this.beforeTemplateRef);
                    }
                    return source;
                }), takeUntil(this.unsubscribe)).subscribe(function (value) {
                    _this.view.clear();
                    _this.errorViewRef = undefined;
                    _this.beforeViewRef = undefined;
                    _this.nextViewRef = _this.view.createEmbeddedView(_this.nextTemplateRef, new ObserveContext(value));
                    _this.changes.markForCheck();
                }, function (error) {
                    if (_this.errorTemplateRef) {
                        _this.view.clear();
                        _this.beforeViewRef = undefined;
                        _this.nextViewRef = undefined;
                        _this.errorViewRef = _this.view.createEmbeddedView(_this.errorTemplateRef, new ErrorContext(error));
                        _this.changes.markForCheck();
                    }
                });
            }
            this.source = source;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NgxObserve.prototype, "ngxObserveError", {
        set: function (ref) {
            assertTemplate('ngxObserveError', ref);
            this.errorTemplateRef = ref;
            if (this.errorViewRef) {
                this.view.clear();
                this.errorViewRef = this.view.createEmbeddedView(this.errorTemplateRef, this.errorViewRef.context);
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NgxObserve.prototype, "ngxObserveBefore", {
        set: function (ref) {
            assertTemplate('ngxObserveBefore', ref);
            this.beforeTemplateRef = ref;
            if (this.beforeViewRef) {
                this.view.clear();
                this.beforeViewRef = this.view.createEmbeddedView(this.beforeTemplateRef);
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NgxObserve.prototype, "ngxObserveNext", {
        set: function (ref) {
            assertTemplate('ngxObserveNext', ref);
            this.nextTemplateRef = ref;
            if (this.nextViewRef) {
                this.view.clear();
                this.nextViewRef = this.view.createEmbeddedView(this.nextTemplateRef, this.nextViewRef.context);
                this.changes.markForCheck();
            }
        },
        enumerable: true,
        configurable: true
    });
    NgxObserve.ngTemplateContextGuard = function (dir, ctx) {
        return true;
    };
    NgxObserve.prototype.ngOnDestroy = function () {
        this.unsubscribe.next(undefined);
    };
    NgxObserve.prototype.ngOnInit = function () {
        this.init.next(undefined);
        this.init.complete();
    };
    NgxObserve.ctorParameters = function () { return [
        { type: ViewContainerRef },
        { type: ChangeDetectorRef },
        { type: TemplateRef }
    ]; };
    __decorate([
        Input()
    ], NgxObserve.prototype, "ngxObserve", null);
    __decorate([
        Input()
    ], NgxObserve.prototype, "ngxObserveError", null);
    __decorate([
        Input()
    ], NgxObserve.prototype, "ngxObserveBefore", null);
    __decorate([
        Input()
    ], NgxObserve.prototype, "ngxObserveNext", null);
    NgxObserve = __decorate([
        Directive({
            selector: '[ngxObserve]'
        })
    ], NgxObserve);
    return NgxObserve;
}());

var NgxObserveModule = /** @class */ (function () {
    function NgxObserveModule() {
    }
    NgxObserveModule = __decorate([
        NgModule({
            declarations: [NgxObserve],
            imports: [],
            exports: [NgxObserve]
        })
    ], NgxObserveModule);
    return NgxObserveModule;
}());

/*
 * Public API Surface of ngx-observe
 */

/**
 * Generated bundle index. Do not edit.
 */

export { ErrorContext, NgxObserve, NgxObserveModule, ObserveContext };
//# sourceMappingURL=ngx-observe.js.map
