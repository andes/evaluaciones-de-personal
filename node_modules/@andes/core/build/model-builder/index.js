"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const api_tool_1 = require("@andes/api-tool");
const query_builder_1 = require("../query-builder");
class ResourceNotFound extends Error {
    constructor() {
        super(...arguments);
        this.status = 404;
        this.message = 'recurso no encontrado';
    }
}
exports.ResourceNotFound = ResourceNotFound;
class ResourceForbidden extends Error {
    constructor() {
        super(...arguments);
        this.status = 403;
        this.message = 'forbidden';
    }
}
exports.ResourceForbidden = ResourceForbidden;
class CustomError extends Error {
    constructor(message, status = 500) {
        super();
        this.status = 500;
        this.message = message;
        this.status = status;
    }
}
exports.CustomError = CustomError;
/**
 * [TODO] Simple searchFilter from schema type by default
 */
class ResourceBase {
    constructor(args) {
        this.keyId = '_id';
        this.resourceModule = '';
        this.resourceName = '';
        this.searchFileds = {};
        this.routesEnable = ['get', 'search', 'post', 'patch', 'delete'];
        this.middlewares = [];
        this.routesAuthorization = {};
        this.extrasRoutes = [];
        this.eventBus = null;
        args = args || {};
        const { eventBus } = args;
        this.eventBus = eventBus;
    }
    /**
     * Popula datos antes de guardar.
     * Se podrÃ­a usar el middleware de mongoose
     */
    async populate(dto) {
        return dto;
    }
    isRouteEnabled(routeName) {
        return this.routesEnable.includes(routeName);
    }
    makeMiddleware(routeName) {
        let localMiddleware = this.routesAuthorization[routeName];
        if (localMiddleware) {
            localMiddleware = Array.isArray(localMiddleware) ? localMiddleware : [localMiddleware];
        }
        else {
            localMiddleware = [];
        }
        return [...this.middlewares, ...localMiddleware];
    }
    checkAuthorization(routeName, req) {
        const checker = this.routesAuthorization[routeName];
        if (!checker) {
            return true;
        }
        if (typeof checker !== 'function') {
            throw new CustomError(`routesAuthorization[${routeName}] must be a function`);
        }
        return checker(req);
    }
    async create(dto, req) {
        dto = await this.populate(dto);
        const document = new this.Model(dto);
        if (document.audit) {
            document.audit(req);
        }
        await document.save();
        if (this.eventBus) {
            this.eventBus.emitAsync(`${this.resourceModule}:${this.resourceName}:create`, document);
        }
        return document;
    }
    async update(id, data, req) {
        const document = await this.findById(id, {});
        if (document) {
            data = await this.populate(data);
            document.set(data);
            if (document.audit) {
                document.audit(req);
            }
            const fieldsChange = document.modifiedPaths();
            await document.save();
            if (this.eventBus) {
                this.eventBus.emitAsync(`${this.resourceModule}:${this.resourceName}:update`, document, fieldsChange);
            }
            return document;
        }
        return null;
    }
    async remove(id) {
        const document = await this.Model.findById(id, {});
        if (document) {
            const state = await document.remove();
            if (this.eventBus) {
                this.eventBus.emitAsync(`${this.resourceModule}:${this.resourceName}:remove`, document);
            }
            return state;
        }
        return null;
    }
    async presearch(data, req) {
        return {};
    }
    async search(data, options, req) {
        const preconditions = await this.presearch(data, req);
        const conditions = query_builder_1.MongoQuery.buildQuery(data, this.searchFileds);
        const { fields, skip, limit, sort } = options;
        let query = this.Model.find({
            ...preconditions,
            ...conditions
        });
        if (fields) {
            query.select(fields);
        }
        if (limit) {
            query.limit(limit);
        }
        if (skip) {
            query.skip(skip);
        }
        if (sort) {
            query.sort(sort);
        }
        return await this.Model.find(query);
    }
    async findById(id, options) {
        const { fields } = options;
        const conditions = {};
        conditions[this.keyId] = id;
        const query = this.Model.findOne(conditions);
        if (fields) {
            query.select(fields);
        }
        return await query;
    }
    makeRoutes() {
        const router = api_tool_1.Router();
        if (this.isRouteEnabled('search')) {
            const middlewares = this.makeMiddleware('search');
            router.get(`/${this.resourceName}`, ...middlewares, api_tool_1.asyncHandler(routesFunctions['search'].bind(this)));
        }
        if (this.isRouteEnabled('get')) {
            const middlewares = this.makeMiddleware('get');
            router.get(`/${this.resourceName}/:id`, ...middlewares, api_tool_1.asyncHandler(routesFunctions['get'].bind(this)));
        }
        if (this.isRouteEnabled('post')) {
            const middlewares = this.makeMiddleware('post');
            router.post(`/${this.resourceName}`, ...middlewares, api_tool_1.asyncHandler(routesFunctions['post'].bind(this)));
        }
        if (this.isRouteEnabled('patch')) {
            const middlewares = this.makeMiddleware('patch');
            router.patch(`/${this.resourceName}/:id`, ...middlewares, api_tool_1.asyncHandler(routesFunctions['patch'].bind(this)));
        }
        if (this.isRouteEnabled('delete')) {
            const middlewares = this.makeMiddleware('delete');
            router.delete(`/${this.resourceName}/:id`, ...middlewares, api_tool_1.asyncHandler(routesFunctions['delete'].bind(this)));
        }
        this.extrasRoutes.forEach((route) => {
            const path = `/${this.resourceName}/${route.path}`;
            const fnMethod = router[route.method || 'get'];
            let middlewares = this.middlewares;
            let callback;
            if (typeof route.callback === 'string') {
                middlewares = this.makeMiddleware(route.callback);
                callback = this[route.callback];
            }
            else {
                callback = route.callback;
            }
            fnMethod.call(router, path, ...middlewares, api_tool_1.asyncHandler(callback.bind(this)));
        });
        return router;
    }
}
exports.ResourceBase = ResourceBase;
const routesFunctions = {
    async search(req, res) {
        const options = req.apiOptions();
        const data = req.query;
        const plantillas = await this.search(data, options, req);
        return res.json(plantillas);
    },
    async get(req, res, next) {
        const options = req.apiOptions();
        const id = req.params.id;
        const document = await this.findById(id, options);
        if (document) {
            return res.json(document);
        }
        else {
            return next('NOT FOUND');
        }
    },
    async post(req, res, next) {
        const body = req.body;
        const document = await this.create(body, req);
        if (document) {
            return res.json(document);
        }
        else {
            return next(422);
        }
    },
    async patch(req, res, next) {
        const id = req.params.id;
        const body = req.body;
        const document = await this.update(id, body, req);
        if (document) {
            return res.json(document);
        }
        else {
            throw new ResourceNotFound();
        }
    },
    async delete(req, res, next) {
        const id = req.params.id;
        const document = await this.remove(id);
        if (document) {
            return res.json(document);
        }
        else {
            throw new ResourceNotFound();
        }
    }
};
//# sourceMappingURL=index.js.map