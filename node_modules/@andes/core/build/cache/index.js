"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const RedisCache = require('node-cache-redis');
const MemoryCache = require('memory-cache');
class AndesCache {
    constructor(options = {}) {
        options = options || {};
        this.name = options.name || 'andes';
        this.adapter = options.adapter || 'memory';
        this.defaultTTL = options.ttl || 60 * 60 * 24;
        this.host = options.host || '127.0.0.1';
        this.port = options.port || 6379;
        if (this.adapter === 'memory') {
            this.memoryCache = new MemoryCache.Cache();
        }
        else {
            this.redisCache = new RedisCache({ name: this.name, redisOptions: { host: this.host, port: this.port } });
        }
    }
    genKey(key) {
        return `${this.name}-${key}`;
    }
    set(key, value, ttl = null) {
        ttl = ttl || this.defaultTTL;
        const genKey = this.genKey(key);
        if (this.adapter === 'memory') {
            return new Promise((resolve) => {
                process.nextTick(() => {
                    this.memoryCache.put(genKey, value, ttl * 1000);
                    return resolve();
                });
            });
        }
        else {
            return this.redisCache.set(genKey, value, ttl);
        }
    }
    get(key) {
        const genKey = this.genKey(key);
        if (this.adapter === 'memory') {
            const value = this.memoryCache.get(genKey);
            return Promise.resolve(value);
        }
        else {
            return this.redisCache.get(genKey);
        }
    }
    clear(key) {
        const genKey = this.genKey(key);
        if (this.adapter === 'memory') {
            const result = this.memoryCache.del(genKey);
            return Promise.resolve(result);
        }
        else {
            return this.redisCache.del(genKey);
        }
    }
}
exports.AndesCache = AndesCache;
//# sourceMappingURL=index.js.map