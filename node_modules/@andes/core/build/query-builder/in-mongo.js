"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const moment = require("moment");
const utils_1 = require("./utils");
const mongoose_1 = require("mongoose");
const util_1 = require("util");
function matchDate(value) {
    let query = {};
    let fecha;
    let fechas = value.split('|');
    if (fechas.length > 1) {
        query = {
            $gte: transformDate(fechas[0], true),
            $lte: transformDate(fechas[1], false)
        };
    }
    else {
        if (value.substr(0, 2) === '>=') {
            fecha = value.substr(2);
            query = { $gte: transformDate(fecha, true) };
        }
        else if (value.substr(0, 1) === '>') {
            fecha = value.substr(1);
            query = { $gt: transformDate(fecha, true) };
        }
        else if (value.substr(0, 2) === '<=') {
            fecha = value.substr(2);
            query = { $lte: transformDate(fecha, true) };
        }
        else if (value.substr(0, 1) === '<') {
            fecha = value.substr(1);
            query = { $lt: transformDate(fecha, true) };
        }
        else {
            query = {
                $gte: transformDate(value, true),
                $lte: transformDate(value, false)
            };
        }
    }
    return query;
}
exports.matchDate = matchDate;
function transformDate(fecha, start) {
    if (moment(fecha, 'YYYY-MM-DD', true).isValid()) {
        if (start) {
            return moment(fecha).startOf('day').toDate();
        }
        else {
            return moment(fecha).endOf('day').toDate();
        }
    }
    else {
        return moment(fecha).toDate();
    }
}
exports.transformDate = transformDate;
function partialString(value) {
    if (value && value.charAt(0) === '^') {
        const searchPattern = value.substring(1);
        return { $regex: utils_1.makePattern(searchPattern) };
    }
    return value;
}
exports.partialString = partialString;
function matchString(value) {
    return value;
}
exports.matchString = matchString;
function equalMatch(value) {
    return value;
}
exports.equalMatch = equalMatch;
/**
 * Devuelve una query con elemMatch por keyName y valueName
 *
 * @param {string} value
 * @param {string} keyName
 * @param {string} valueName
 */
function queryMatch(value, keyName, valueName) {
    let ids = value.split('|');
    let filtro = {};
    if (ids[0]) {
        filtro[keyName] = ids[0];
    }
    if (ids[1]) {
        if (mongoose_1.Types.ObjectId.isValid(ids[1])) {
            filtro[valueName] = mongoose_1.Types.ObjectId(ids[1]);
        }
        else {
            filtro[valueName] = partialString(ids[1]);
        }
    }
    return { $elemMatch: filtro };
}
exports.queryMatch = queryMatch;
/**
 * Devuelve una condición con operador (and, or) para buscar elementos en un arreglo a través del elemMatch
 *
 * @export
 * @param {string} fieldName
 * @param {Array<string>} values
 * @param {string} keyName
 * @param {string} valueName
 * @returns {Object}
 */
function queryArray(fieldName, values, keyName, valueName, op = 'and') {
    values = Array.isArray(values) ? values : [values];
    const conds = [];
    values.forEach(valor => {
        const filtro = {};
        filtro[fieldName] = queryMatch(valor, keyName, valueName);
        conds.push(filtro);
    });
    if (op === 'or') {
        return { $or: conds };
    }
    return { $and: conds };
}
exports.queryArray = queryArray;
function processParam(fieldName, queryParam) {
    const isFunction = typeof queryParam === 'function';
    const callback = isFunction ? queryParam : queryParam.fn;
    const field = isFunction ? fieldName : queryParam.field;
    return [field, callback];
}
function buildQuery(query, searchSpecification) {
    const mongoQuery = {};
    const $and = [];
    Object.keys(query).forEach((item) => {
        if (util_1.isNullOrUndefined(searchSpecification[item])) {
            return;
        }
        const specification = searchSpecification[item];
        const filterValue = query[item];
        if (Array.isArray(specification)) {
            const $or = {
                $or: specification.map(i => {
                    const [field, callback] = processParam(i, searchSpecification[i]);
                    const constrain = callback(filterValue, query);
                    if (!constrain['$and'] && !constrain['$or']) {
                        return { [field]: constrain };
                    }
                    else {
                        return constrain;
                    }
                })
            };
            $and.push($or);
        }
        else {
            const [field, callback] = processParam(item, specification);
            const constrain = callback(filterValue, query);
            if (!constrain['$and'] && !constrain['$or']) {
                mongoQuery[field] = constrain;
            }
            else {
                $and.push(constrain);
            }
        }
    });
    if ($and.length > 0) {
        mongoQuery['$and'] = $and;
    }
    return mongoQuery;
}
exports.buildQuery = buildQuery;
exports.MongoQuery = {
    equalMatch,
    matchDate,
    partialString,
    matchString,
    queryMatch,
    queryArray,
    buildQuery
};
//# sourceMappingURL=in-mongo.js.map